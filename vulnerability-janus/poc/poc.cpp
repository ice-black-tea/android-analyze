#include <zlib.h>
#include "include/ZipArchive.h"
#include "include/DexFile.h"
#include "include/sha1.h"

#define offsetof(s,m) (size_t)&(((s *)0)->m)

struct FileDescriptor {
    FileDescriptor(const char *path, int flags){
        mPath = path;
        mFile = open64(path, flags);
    }
    FileDescriptor(const char *path, int flags, mode_t mode){
        mPath = path;
        mFile = open64(path, flags, mode);
    }
    ~FileDescriptor() {
        if (mFile > 0) close(mFile);
    }
    operator int& () {
        return mFile;
    }
    off64_t     mSize; // 文件大小
    int         mFile; // 文件描述符
    const char *mPath; //文件路径
};

// 合并文件
int32_t MergeFile(FileDescriptor *out, FileDescriptor *apk, FileDescriptor *dex) {

    lseek64(*out, 0, SEEK_SET);

    // 读取dex文件内容
    lseek64(*dex, 0, SEEK_SET);
    char *buf = (char*) malloc(dex->mSize);
    read(*dex, buf, dex->mSize);

    // 把dex文件内容放在开头
    write(*out, buf, dex->mSize);
    free(buf);
    ALOGV("append dex file success");

    // 读取apk文件内容
    lseek64(*apk, 0, SEEK_SET);
    buf = (char*) malloc(apk->mSize);
    read(*apk, buf, apk->mSize);

    // 后面附加apk文件内容
    write(*out, buf, apk->mSize);
    free(buf);
    ALOGV("append apk file success");

    // 修改目标文件的大小
    out->mSize = apk->mSize + dex->mSize;

    return 0;
}

// 修复zip部分数据
int32_t RepairZip(FileDescriptor *out, off64_t offset, size_t length) {
    // 将apk文件部分映射到内存
    FileMap map;
    map.create(out->mPath, *out, offset, length, false);

    // apk文件起始位置
    uint8_t *start = reinterpret_cast<uint8_t*>(map.getDataPtr());
    EocdRecord* eocd =
        reinterpret_cast<EocdRecord*>(start + map.getDataLength() - sizeof(EocdRecord));
    uint8_t* cd_ptr =
        reinterpret_cast<uint8_t*>(start + eocd->cd_start_offset);
    uint16_t num_entries = eocd->num_records;

    // 修改cd_start_offset偏移
    eocd->cd_start_offset += offset;
    ALOGV("cd_start_offset: %d", eocd->cd_start_offset);

    // 遍历所有entry， 修改file_header_offset
    uint8_t* ptr = cd_ptr;
    for (uint16_t i = 0; i < num_entries; i++) {
        CentralDirectoryRecord* cdr = reinterpret_cast<CentralDirectoryRecord*>(ptr);

        const uint16_t file_name_length = cdr->file_name_length;
        const uint16_t extra_length = cdr->extra_field_length;
        const uint16_t comment_length = cdr->comment_length;

        // file_header_offset往后挪
        cdr->local_file_header_offset += offset;

        // const uint8_t* file_name = ptr + sizeof(CentralDirectoryRecord);
        // ALOGV("entry: %s  offset: %d", file_name, cdr->local_file_header_offset);

        ptr += sizeof(CentralDirectoryRecord) + file_name_length + extra_length + comment_length;
    }

    return 0;
}

// 修复dex部分数据
int32_t RepairDex(FileDescriptor *out) {

    // 将apk文件部分映射到内存
    FileMap map;
    map.create(out->mPath, *out, 0, out->mSize, false);

    DexHeader *header = reinterpret_cast<DexHeader*>(map.getDataPtr());

    header->fileSize = out->mSize;
    header->headerSize = sizeof(DexHeader);

    //修复sha-1
    unsigned char sha1Digest[kSHA1DigestLen];
    SHA1_CTX context;
    SHA1Init(&context);
    SHA1Update(&context, (unsigned char*)&header->fileSize,
        header->fileSize - offsetof(DexHeader, fileSize));
    SHA1Final(sha1Digest, &context);
    memcpy(header->signature, sha1Digest, sizeof(sha1Digest));
    ALOGV("out file signature: %s", header->signature);

    //修复校验和
    uLong adler = adler32(0L, Z_NULL, 0);
    adler = adler32(adler, (Bytef*)header->signature,
        header->fileSize - offsetof(DexHeader, signature));
    header->checksum = adler;
    ALOGV("out file checksum: 0x%08X", header->checksum);

    return 0;
}

int32_t PatchFile(const char *outPath, const char *apkPath, const char *dexPath) {

    FileDescriptor out(outPath, O_CREAT | O_RDWR | O_TRUNC, S_IRWXU);
    if (out <= 0) {
        ALOGE("create out file(%s) failed: %s", outPath, strerror(errno));
        return -1;
    }

    FileDescriptor apk(apkPath, O_RDWR);
    if (apk <= 0) {
        ALOGE("open apk file(%s) failed: %s", apkPath, strerror(errno));
        return -1;
    }

    FileDescriptor dex(dexPath, O_RDWR);
    if (dex <= 0) {
        ALOGE("open dex file(%s) failed: %s", dexPath, strerror(errno));
        return -1;
    }

    // 文件大小
    dex.mSize = lseek64(dex, 0, SEEK_END);
    apk.mSize = lseek64(apk, 0, SEEK_END);
    ALOGV("dex file size: %ld b", dex.mSize);
    ALOGV("apk file size: %ld b", apk.mSize);

    if (MergeFile(&out, &apk, &dex) < 0) {
        ALOGE("merge file failed");
        return -1;
    }

    ALOGV("out file size: %ld b", out.mSize);

    if (RepairZip(&out, dex.mSize, apk.mSize) < 0) {
        ALOGE("repair zip file failed");
        return -1;
    }

    if (RepairDex(&out) < 0) {
        ALOGE("repair dex file failed");
        return -1;
    }

    ALOGV("success");

    return 0;
}

int main(int argc, char *argv[]) {
    if (argc != 4) {
        printf("%s {apk path} {dex path} {out path}\n", strrchr(argv[0], '/') + 1);
    } else {
        PatchFile(argv[3], argv[1], argv[2]);
    }
    return 0;
}
